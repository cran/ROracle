/* R and S-Plus Database Interface to Oracle */
/* 
 * $Id: RS-Oracle.pc 154 2006-02-08 19:16:04Z dj $ 
 *
 * vim:syntax=c 
 */

/* Copyright (C) 1999-2003 The Omega Project for Statistical Computing.
 *
 * http://www.omegahat.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

/* 
 * Limitations/TODO:
 *
 *  - Only handle up to 255 bytes per field.  - Max num of 10 simultaneous
 *  connections.  - One open results set per connection.  - No asychronous
 *  operations.  - Haven't implemented any of the Oracle RAW types.  - Make
 *  sure we don't leave any variables/structs that may make this code thread
 *  unsafe.  - Move the transaction control to their own functions so that they
 *  can be invoked by the dbConnection methods explicitly.
 */

/*
 * This driver connects S-Plus or R to Oracle and implements the 
 * DBI generic R/S-database interface 0.1-4.  This driver is implemented
 * using Embedded C/C++ (i.e., a pre-compiler) which restricts the code
 * somewhat, but it may (?) allow us to re-use it for other DBMS, e.g.,
 * Informix, Sybase, Ingres. [But see comments further down.]
 *
 * The Oracle dynamic SQL is based on the Oracle's ProC  sample10.pc 
 * program in $ORACLE_HOME/proc/demo/sample10.pc. 
 * For more details see:
 *  On S4, Appendix A in "Programming with Data" by John M. Chambers
 *     Springer, 1998.
 *  On R, "The .Call and .External Interfaces"  Manual by the R Core
 *     Team, http://cran.r-project.org
 *  On Oracle, "The ProC/C++ Precompiler -- Programmer's Manual Rel 8.0".
 *  On the SQL standard, "The X/Open CAE Specification, SQL and RDA,"
 *     published by the X/Open Company, Ltd., UK (1994).
 * 
 * by David A. James (Bell Labs, Lucent Technologies)
 *    T Jake Luciani (Lucent Optoelectronics)
 * 
 * WARNINGS:
 *   EXEC SQL statements are pre-processed, thus some quirks get
 *   introduced.  In particular their scope is **positional** not
 *   only logical, thus you should be careful not to place them out of
 *   order physically in the file (the order is dictated at
 *   pre-compile time, not execution time).  Moreover, the embedded
 *   method introduces yet-another scoping space where cursor names
 *   and dynamic statements are defined -- e.g., cursor names must
 *   be unique within this file but also on the SQLLIB underlying 
 *   API's private structs.  Moreover, as of 8.1.7 we cannot dynamically 
 *   store/restore cursor names in C structs, thus we're limited to 
 *   pre-allocating (at pre-compilation) a pool of cursors that we 
 *   manage very clumsily thru switches (Grrr!).  This has forced us
 *   to allow only 1 open select statement (cursor) per connection.
 *   [Informix does provide a "dynamic cursor" facility since, at
 *   least, version 7.2]
 *   See Chapters 4, 11, 12, 14 in the ProC/C++ manual for the gory details.
 *
 *   Notice also, that one of the S-Plus header files (cdef.h in 5.1+) 
 *   causes the oracle precompiler to fail, thus we need to invoke with
 *   PARSE = PARTIAL flag, although it still generates some warnings
 *   (see the makefile).  Don MacQueen has reported similar problems with 
 *   R 1.6.2 on Mac OS/X (10.2, Jaguar).
 * 
 *   The original thought was to implement this Oracle driver using embedded
 *   SQL to make the code easy to port to Informix, Ingres, DB2, etc.
 *   But I now feel that it was not worth the aggravation.  Using OCI 
 *   directly would have been easier and we could better exploit  
 *   Oracle's performance.  
 *
 */

EXEC SQL INCLUDE RS-Oracle.h;

/* Create the dbmanager (singleton) object */
Mgr_Handle *
RS_Ora_init(s_object *config_params, s_object *reload)
{
  S_EVALUATOR
  Mgr_Handle *mgrHandle;
  const char *drvName = "Oracle (ProC/C++)";         /* say, instead of OCI */
  Sint  fetch_default_rec, max_con, force_reload;
  
  max_con = INT_EL(config_params, 0);
  fetch_default_rec = INT_EL(config_params,1);
  force_reload = LGL_EL(reload, 0);

  mgrHandle = RS_DBI_allocManager(drvName, max_con, 
				 fetch_default_rec, force_reload);
  return mgrHandle;
}

s_object *    /* returns TRUE/FALSE */
RS_Ora_close(Mgr_Handle *mgrHandle)
{
  S_EVALUATOR
  s_object *status;

  RS_DBI_freeManager(mgrHandle);
  MEM_PROTECT(status = NEW_LOGICAL((Sint) 1));
  LGL_EL(status, 0) = TRUE;
  MEM_UNPROTECT(1);
  return status;
}

RS_Ora_conParams *
RS_Ora_allocConParams(void)
{
  RS_Ora_conParams *conParams;
  conParams = (RS_Ora_conParams *) malloc(sizeof(RS_Ora_conParams));  
  if(!conParams)
    RS_DBI_errorMessage("could not malloc connection parameters object",
		 RS_DBI_ERROR);
  conParams->dbname = (char *) NULL;
  conParams->user   = (char *) NULL;
  conParams->passwd = (char *) NULL;
  return conParams;
}

void
RS_Ora_freeConParams(RS_Ora_conParams *conParams)
{
  if(!conParams)
    RS_DBI_errorMessage("cannot free un-initialized RS_Ora_conParams",
		 RS_DBI_WARNING);
  if(conParams->dbname) free(conParams->dbname);
  if(conParams->user) free(conParams->user);
  if(conParams->passwd) free(conParams->passwd);
  conParams = (RS_Ora_conParams *) NULL;
  return;
}

Con_Handle *
RS_Ora_newConnection(Mgr_Handle *mgrHandle, s_object *conn_params, 
		     s_object *max_res)
{
  /* From R/S (not in this C file) we implement the following ways of 
   * connecting to an Oracle database. (This routine *must* get the 3 
   * parameters username, password, dbname.)
   *   (1) "/"                    (ie., automatic connect)
   *   (2) user, password         (on $ORACLE_SID default connection)
   *   (3) user, password, dbname (using Net8 service names)
   *   (4) user/password@dbname
   * See Ch 4, pp 21-on in the ProC/C++ manual.
   */
  S_EVALUATOR
  Con_Handle        *conHandle = NULL;
  RS_Ora_conParams  *conParams = NULL;
  RS_DBI_connection *con = NULL;
  char   alias[128];
  int    cursorNum;

#define ORA_BUF_LEN  1024

  EXEC SQL BEGIN DECLARE SECTION;
    VARCHAR  username[1024];
    VARCHAR  password[1024];
    VARCHAR  dbname[1024];/* this is an SQL*Net8 TNSNAME (but Oracle */
                                 /* gurus/Perl Hackers seem to overload this*/
                                 /* to include the full tnsname.ora string) */
  EXEC SQL END DECLARE SECTION;

  /* create a connection and assign it to the dbManager 
   * TODO: currently we can only have 1 open resultSet 
   */

  conParams = RS_Ora_allocConParams();
  conParams->user = RS_DBI_nCopyString(CHR_EL(conn_params,0), ORA_BUF_LEN,0);
#define IS_EMPTY(s1)   !strcmp((s1), "")
/* 
  if(IS_EMPTY(conParams->user)){
     RS_Ora_freeConParams(conParams);
     RS_DBI_errorMessage("username must be non-empty", RS_DBI_ERROR);
  }
*/
  conParams->passwd = RS_DBI_nCopyString(CHR_EL(conn_params,1), ORA_BUF_LEN,0);
/*
  if(IS_EMPTY(conParams->passwd)){
     RS_Ora_freeConParams(conParams);
     RS_DBI_errorMessage("password must be non-empty", RS_DBI_ERROR);
  }
*/
  conParams->dbname = RS_DBI_nCopyString(CHR_EL(conn_params,2), ORA_BUF_LEN,0);
  if(IS_EMPTY(conParams->dbname)){
     RS_Ora_freeConParams(conParams);
     RS_DBI_errorMessage("dbname must be non-empty", RS_DBI_ERROR);
  }
  
  conHandle = RS_DBI_allocConnection(mgrHandle, INT_EL(max_res,0));
  con = RS_DBI_getConnection(conHandle);
  con->conParams = (void *) conParams;
  cursorNum = RS_Ora_getCursorNum(conHandle);

  RS_Ora_varCharCpy(&username, conParams->user);
  RS_Ora_varCharCpy(&password, conParams->passwd);
  RS_Ora_varCharCpy(&dbname,   conParams->dbname);

  EXEC SQL WHENEVER SQLERROR GOTO connect_error;

  /* We always use :db_alias to name connections. */
  (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
  RS_Ora_varCharCpy(&db_alias, alias);

  EXEC SQL CONNECT :username IDENTIFIED BY :password AT :db_alias USING :dbname;

  return conHandle;
    
 connect_error:
  if(conParams){
    RS_Ora_freeConParams(conParams);
    con->conParams = conParams = (RS_Ora_conParams *) NULL;
    RS_DBI_freeConnection(conHandle);
  }
  RS_Ora_error();
  return (Con_Handle *)NULL;
}

Con_Handle *
RS_Ora_cloneConnection(Con_Handle *conHandle)
{
  S_EVALUATOR
  Mgr_Handle  *mgrHandle;
  RS_DBI_connection  *con;
  RS_Ora_conParams *conParams;
  s_object    *con_params, *max_res;

  /* use existing connection's parameters to create a new connection */
  if(LENGTH(conHandle)<2)
     RS_DBI_errorMessage("corrupt connection handle?", RS_DBI_ERROR);
  con = RS_DBI_getConnection(conHandle);
  conParams = con->conParams;
  mgrHandle = RS_DBI_asMgrHandle(MGR_ID(conHandle));

  MEM_PROTECT(con_params = NEW_CHARACTER((Sint) 3));
  SET_CHR_EL(con_params,0, C_S_CPY(conParams->user));
  SET_CHR_EL(con_params,1, C_S_CPY(conParams->passwd));
  SET_CHR_EL(con_params,2, C_S_CPY(conParams->dbname));

  MEM_PROTECT(max_res = NEW_INTEGER((Sint) 1));
  INT_EL(max_res,0) = con->length;

  MEM_UNPROTECT(2);
  return RS_Ora_newConnection(mgrHandle, con_params, max_res);
}

s_object *    /* boolean */
RS_Ora_closeConnection(Con_Handle *conHandle)
{
  S_EVALUATOR
  s_object *status;
  RS_DBI_connection *con;

  con = RS_DBI_getConnection(conHandle);
  MEM_PROTECT(status = NEW_LOGICAL((Sint) 1));
  if(con==(RS_DBI_connection *)NULL){
    LGL_EL(status,0) = TRUE;
    MEM_UNPROTECT(1);
    return status;
  }
    
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL COMMIT RELEASE;

  RS_Ora_freeConParams((RS_Ora_conParams *) con->conParams);
  con->conParams = (void *) NULL;
  RS_DBI_freeConnection(conHandle);

  LGL_EL(status,0) = TRUE;
  MEM_UNPROTECT(1);

  return status;
}  

/* Bug Workaround. The following is a workaround for a bug in the Linux 
 * proC/C++ precompiler -- it incorrectly returns the error 
 * "fetch out of sequence" when executing any statement (even though 
 * we're executing, not *fetching* any records) [I believe the bug occurs
 * when using the "AT :db_alias" in the EXEC SQL, which we're doing here.]
 * This occurs with Oracle 8.1.[567].  
 */
int
buggy_ora_error()
{
   switch(sqlca.sqlcode){
   case -1002: /* fetch out of sequence */
       return 1;
       break;
   default:
       return 0;
       break;
   }
}
#define filter_prepare_error_bug() { if(!buggy_ora_error()) goto prepare_error;}
#define filter_exec_error_bug()   { if(!buggy_ora_error()) goto exec_error;}

Res_Handle *
RS_Ora_prepareStatement(
   Con_Handle *conHandle, 
   s_object *statement, 
   s_object *s_bind_classes)  /* classes of the binding S columns */
{
  /* Prepare one dyn sql statement (INSERT, DELETE, SELECT, etc.),
   * optionally bound R/S-Plus fields in a data.frame to Oracle buffers.
   * Returns handle to a (half-formed) resultSet object.  This proto result
   * set does not have yet the result of the sql statment -- that needs to
   * be done in the RS_Ora_exec() function, where fields from an optional
   * input data.frame are copied to Oracle's buffers for transfer to the
   * server. Note that we're effectively creating an Oracle cursor.  We 
   * could define RS_Ora_prepareStatement as a generator for a cursor.
   *
   * Note that pre-compiling doesn't allow us to save/restore cursors
   * and other goodies, so it gets a bit dirty having to switch
   * among a pre-defined set of cursor managed by the cursor table.
   *
   * The sqlca (SQL Communication Area) struct holds a number of goodies
   * describing the state of the last SQL statement, in particular,
   * sqlca.sqlcode is the return code of the last statemnet, and the
   * array sqlca.sqlerr[] holds number of affected rows, etc. (for details
   * see the ProC/C++ manual, Ch. 11, p 15, 12-28, )
   */
  S_EVALUATOR

  RS_Ora_desArea *desArea = NULL; 
  SQLDA  *bind_dp;
  char alias[128];

  EXEC SQL BEGIN DECLARE SECTION;
     char   dyn_statement[20000];
     EXEC SQL VAR dyn_statement IS STRING(20000);
  EXEC SQL END DECLARE SECTION;

  RS_DBI_resultSet  *result;
  Res_Handle  *rsHandle;
  size_t   stmt_len = RS_ORA_STATEMENT_LEN, sqlFunCode;
  char     deparsed_stmt[RS_ORA_STATEMENT_LEN];
  int      n_params;
  int      cursorNum;
  Sint     buf_size;                /* num of rows per Oracle fetch */

  if(strlen(CHR_EL(statement,0))>=RS_ORA_STATEMENT_LEN){
     char errMsg[128];
     (void) sprintf(errMsg,
                    "too long a statement -- it must has less than %ld chars",
                    (long) RS_ORA_STATEMENT_LEN);
     RS_DBI_errorMessage(errMsg, RS_DBI_ERROR);
  }

  rsHandle = RS_DBI_allocResultSet(conHandle);
  result = RS_DBI_getResultSet(rsHandle);

  /* Oracle needs dyn_statement */
  (void) strncpy(dyn_statement, CHR_EL(statement,0), RS_ORA_STATEMENT_LEN);
  buf_size = RS_ORA_DEFAULT_BUFFER_SIZE;
  desArea = RS_Ora_allocDescriptors(RS_ORA_MAX_ITEMS, 
			   RS_ORA_MAX_VNAME_LEN, 
			   RS_ORA_MAX_VNAME_LEN,
                           buf_size);
  bind_dp = desArea->bindVars;

  /* EXEC SQL WHENEVER SQLERROR GOTO prepare_error; */
  EXEC SQL WHENEVER SQLERROR DO filter_prepare_error_bug();
  cursorNum = RS_Ora_getCursorNum(rsHandle);
  (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
  RS_Ora_varCharCpy(&db_alias, alias);
  switch(cursorNum) {
  case 0:
    EXEC SQL AT :db_alias DECLARE S_00 STATEMENT;
    EXEC SQL PREPARE S_00 FROM :dyn_statement;
    EXEC SQL DECLARE C_00 CURSOR FOR S_00;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_00 INTO bind_dp;
    break;
  case 1:
    EXEC SQL AT :db_alias DECLARE S_01 STATEMENT;
    EXEC SQL PREPARE S_01 FROM :dyn_statement;
    EXEC SQL DECLARE C_01 CURSOR FOR S_01;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_01 INTO bind_dp;
    break;
  case 2:
    EXEC SQL AT :db_alias DECLARE S_02 STATEMENT;
    EXEC SQL PREPARE S_02 FROM :dyn_statement;
    EXEC SQL DECLARE C_02 CURSOR FOR S_02;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_02 INTO bind_dp;
    break;
  case 3:
    EXEC SQL AT :db_alias DECLARE S_03 STATEMENT;
    EXEC SQL PREPARE S_03 FROM :dyn_statement;
    EXEC SQL DECLARE C_03 CURSOR FOR S_03;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_03 INTO bind_dp;
    break;
  case 4:
    EXEC SQL AT :db_alias DECLARE S_04 STATEMENT;
    EXEC SQL PREPARE S_04 FROM :dyn_statement;
    EXEC SQL DECLARE C_04 CURSOR FOR S_04;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_04 INTO bind_dp;
    break;
  case 5:
    EXEC SQL AT :db_alias DECLARE S_05 STATEMENT;
    EXEC SQL PREPARE S_05 FROM :dyn_statement;
    EXEC SQL DECLARE C_05 CURSOR FOR S_05;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_05 INTO bind_dp;
    break;
  case 6:
    EXEC SQL AT :db_alias DECLARE S_06 STATEMENT;
    EXEC SQL PREPARE S_06 FROM :dyn_statement;
    EXEC SQL DECLARE C_06 CURSOR FOR S_06;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_06 INTO bind_dp;
    break;
  case 7:
    EXEC SQL AT :db_alias DECLARE S_07 STATEMENT;
    EXEC SQL PREPARE S_07 FROM :dyn_statement;
    EXEC SQL DECLARE C_07 CURSOR FOR S_07;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_07 INTO bind_dp;
    break;
  case 8:
    EXEC SQL AT :db_alias DECLARE S_08 STATEMENT;
    EXEC SQL PREPARE S_08 FROM :dyn_statement;
    EXEC SQL DECLARE C_08 CURSOR FOR S_08;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_08 INTO bind_dp;
    break;
  case 9:
    EXEC SQL AT :db_alias DECLARE S_09 STATEMENT;
    EXEC SQL PREPARE S_09 FROM :dyn_statement;
    EXEC SQL DECLARE C_09 CURSOR FOR S_09;
    EXEC SQL DESCRIBE BIND VARIABLES FOR S_09 INTO bind_dp;
    break;
  default:
    goto prepare_error;
    break;
  }

  result->statement = RS_DBI_copyString(CHR_EL(statement,0));
  result->rowsAffected = (Sint) -1;  /* to be determined */
  result->rowCount = (Sint) -1;      /* to be determined */
  result->completed = (Sint) -1;     /* to be determined */

  /* set the S -> Oracle mapping through bound parametes in desArea.
   * TODO: Note that the result set object itself does not record whether 
   * there are bound params or not -- this is (currently) recorded in 
   * the *desArea structure (that's fine, but probably we want to 
   * formalize this as a slot, ie., struct member, in the resultSet).
   */
  n_params = RS_Ora_setSToOraMappings(desArea, s_bind_classes);
  if(n_params<0) goto prepare_error;
  result->drvData = (void *) desArea;

  /* sqlgls() describes the parsed SQL statements (insert, select, etc.) */
  sqlgls(deparsed_stmt, &stmt_len, &sqlFunCode);

#ifndef RS_ORA_SQLGLS_WORKAROUND
  result->isSelect  = (Sint) (sqlFunCode == ORA_SQL_CODE_SELECT);
#else
  /* Workaround for the Oracle 9.2.0.x sqlgls() bug, as per David Hinds' 
   * patch.
   */
  { 
    int i;
    for(i=0; i<stmt_len; i++)              /* convert to uppercase */
      if(isalpha(deparsed_stmt[i]))
         deparsed_stmt[i] = toupper(deparsed_stmt[i]);
    for(i=0; i<stmt_len; i++)              /* skip whitespace */
      if(isgraph(deparsed_stmt[i])) break;
    result->isSelect = 
      (Sint) (strncmp(deparsed_stmt, "SELECT", (size_t) 6)==0 ||
              strncmp(deparsed_stmt, "WITH",   (size_t) 4)==0);
  }
#endif

#if 0
  /* here we show that sqlgls() is returning wrong codes in Oracle 9.2.0.1
   * on Windows (I had no problems whatsoever in Linux/Oracle 8.1.7.0.1). 
   * Note that the sql code appears to be lagged 1 sqlgls() function call.  
   * The most relevant codes are:
   * 1==create table,  3==insert, 4==select, 5==update, 8==drop table
   */
  {
    char *str;  
    if(stmt_len!=0){
       str = (char *) malloc((size_t) stmt_len+1);
       (void) strncpy(str, deparsed_stmt, stmt_len);
       str[stmt_len] = '\0';
    }
    else
       str = (char *) calloc((size_t) 1, (size_t) 1);
    fprintf(stderr, "-------------------- DEBUG --------------------\n");
    fprintf(stderr, "R stmt  =%s\n", result->statement);
    if(stmt_len>0)
    fprintf(stderr, "Ora stmt=%s\n", str);
    fprintf(stderr, "Ora stmt_len=%d\n", (int) stmt_len);
    fprintf(stderr, "isSelect=%d\tsqlFunCode=%d\tsqlcode=%d\n",
       (int) result->isSelect, (int) sqlFunCode, (int) sqlca.sqlcode);
    fprintf(stderr, "-----------------------------------------------\n");
    fflush(stderr);
  }
#endif
  return rsHandle; 

prepare_error:
  if(desArea)
    RS_Ora_freeDescriptors(desArea);
  RS_DBI_freeResultSet(rsHandle);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  RS_Ora_error();
  return (Res_Handle *) NULL;
}

Res_Handle *
RS_Ora_exec(Res_Handle *resHandle, 
   s_object *s_dataFrame,
   s_object *s_data_classes,
   s_object *ora_buf_size)
{
   /* Limitation:  We don't fully implement sql statements that are select
    * AND that have input parameters larger than one bufferSize rows.  The
    * reason is somewhat complicated and due to the fact that each time
    * we need to refill the buffers we need to re-OPEN cursors -- this in turn
    * clears the active set.  With these limitations we should cache both
    * the input (bound) data.frame *AND* the output of the select statement,
    * which we don't currently do.  [Or re-implement using Oracle's OCI API.)
    */

   S_EVALUATOR 

   RS_DBI_resultSet *res;
   RS_Ora_desArea  *desArea;
   SQLDA  *bind_dp;          /* SQL descriptor area for bind variables */
   SQLDA  *select_dp;        /* SQL descriptor area for select'ed fields*/
   int    cursorNum, isSelect, batchNum;
   char   alias[128]; 
   Sint   numParams, bufferSize, nr, i;
   
   EXEC SQL BEGIN DECLARE SECTION;
   int n ;
   EXEC SQL END DECLARE SECTION;
   
   res = RS_DBI_getResultSet(resHandle);
   desArea = (RS_Ora_desArea *) res->drvData;
   batchNum  = desArea->batchNum;
   numParams = desArea->numParams;

   /* Special case: statement already executed once w. no bound params */
   if(batchNum>0 && numParams==0)
      return resHandle;

   select_dp = desArea->selectFlds;
   bind_dp = desArea->bindVars;
   isSelect = (int) res->isSelect;

   bufferSize = INT_EL(ora_buf_size, 0);
   if(bufferSize<=0)
      bufferSize = desArea->bufferSize;

   /* Limitation: select statement with input too big for one buffer trip */
   nr = GET_LENGTH(LST_EL(s_dataFrame, 0));
   if(isSelect && nr > bufferSize){
      char err_msg[1024];
      (void) sprintf(err_msg, 
                     "exceeded limit on input data.frame, must have <=%ld rows", 
                     (long) bufferSize);
      RS_DBI_errorMessage(err_msg, RS_DBI_ERROR);
   }

   cursorNum = RS_Ora_getCursorNum(resHandle);
   (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
   RS_Ora_varCharCpy(&db_alias, alias);
   EXEC SQL WHENEVER SQLERROR DO filter_exec_error_bug();
   switch(cursorNum){
         /* Yet one more precompiling shortcoming.  The OPEN embedded statement
          * executes the SQL, but in cases when we needed to fill the buffers
          * multiple times, we need to re-open the cursor to change the input
          * variables.  Closing and opening cursors can be relatively
          * expensive, so Oracle allows us to re-open a cursor w.o. closing it,
          * but this behaviour depends on having the proc option MODE=Oracle,
          * which it's the default value.  See the Pro C/C++ manual p. 5-13
          * and Appendix F-59 for details
          *
          * WARNING: re-opening a cursor resets the number of rows processed in
          *          sqlca.sqlerrd[2] and the active (output) set.
          * WARNING: Appendix F in the ProC/C++ manual did not list the "FOR :n"
          *          predicate to the OPEN cursor statement.  An oversight?
          */
      case 0: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_00;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_00;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_00 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               /* sqlerrd[2] stores cum num of affected rows per OPEN */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_00 INTO select_dp;
         break;
      case 1: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_01;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_01;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_01 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_01 INTO select_dp;
         break;
      case 2: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_02;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_02;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_02 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_02 INTO select_dp;
         break;
      case 3: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_03;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_03;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_03 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_03 INTO select_dp;
         break;
      case 4: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_04;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_04;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_04 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_04 INTO select_dp;
         break;
      case 5: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_05;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_05;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_05 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_05 INTO select_dp;
         break;
      case 6: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_06;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_06;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_06 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_06 INTO select_dp;
         break;
      case 7: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_07;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_07;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_07 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_07 INTO select_dp;
         break;
      case 8: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_08;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_08;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_08 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_08 INTO select_dp;
         break;
      case 9: 
         if(numParams==0){                        /* no bound variables   */
            EXEC SQL OPEN C_09;                   /* no need of bind info */
            if(!isSelect) EXEC SQL CLOSE C_09;    /* no output, thus done */
         }
         else{
            if(desArea->batchNum==0) 
               res->rowsAffected=0;
            for(i = 0; i<nr; i += n){
               n = RS_Ora_cpyDataFrameToOra(s_dataFrame, s_data_classes,
                                            i, bufferSize, desArea);
               EXEC SQL FOR :n OPEN C_09 USING DESCRIPTOR bind_dp;  
               desArea->batchNum += 1;            /* one more Oracle batch */
               res->rowsAffected += sqlca.sqlerrd[2]; 
            }
         }
         if(isSelect)
            EXEC SQL DESCRIBE SELECT LIST FOR S_09 INTO select_dp;
         break;
   }

   res->drvData = (void *) desArea;
   res->isSelect = (Sint) isSelect;
   if(isSelect){
      res->fields = RS_Ora_setOraToSMappings(desArea);
      res->rowsAffected = (Sint) 0;         /* not set w. SELECTs */
      res->completed = (Sint) 0;            /* there are rows to fetch */
   }
   else 
      res->completed = (numParams==0);

  return resHandle;

exec_error:
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  RS_Ora_error();
  return resHandle;     /* unreachable, but for gcc -Wall's sake */
}

RS_DBI_fields *
RS_Ora_setOraToSMappings(RS_Ora_desArea *desArea)
{
  /* The Oracle trick is to loop over the full field descritption in
   * the select_dp structure and for each oracle type set an S mode.
   * A few dirty details come up, like oracle's way of using the high-
   * order bit of the Type spec to record whether that field/column
   * can take NULL values (that bit, obviously, needs to be cleared
   * to get the correct Type code), and the way NUMBER's precision and
   * scale map into integers, floats, etc.  We made some arbitrary decision
   * on the mapping of some Oracle types to S modes, and they are noted
   * in the comments below.  Please let us know if you have better
   * alternatives.  BTW, this is the part that other drivers need
   * to hard code as well (e.g., Informix, m[y]SQL, Sysbase, ....)
   */

  /* records to bring into C (not R/S-Plus) per fetch.  
   *
   * NOTE: The use of host arrays with the ProC/C++ has size limitations, 
   * in particular, each host array has to have less than 32767/sizeof(type) 
   * elements (ProC/C++ Manual, p. 12-2).
   */
  int bufferSize = desArea->bufferSize; 

  SQLDA *select_dp = NULL;
  RS_DBI_fields *flds;
  int  num_fields;
  Sint  j, null_ok, precision, scale;
  char  errMsg[128];
  short ORACLE_internal_type;
  select_dp = desArea->selectFlds;
  select_dp->N = select_dp->F;   /* sets actual num of selected columns*/
  num_fields = (int) select_dp->F;
  flds = RS_DBI_allocFields(num_fields);

  for (j = 0; j < num_fields; j++){
    /* First, save the name, Oracle's internal field name, type, 
     * length, etc.  Then re-set the type (T) and length (L) field 
     * in select_dp->T[j] to set the coercion that ProC/C++ will
     * do for us.  Recall, the field names are in S, with max M chars
     * but current length C (See Ch. 14, p 10 and Fig 14-6 on p. 14-31)
     */
    flds->name[j] = RS_DBI_nCopyString(select_dp->S[j], 
				       select_dp->C[j], /* len of fname*/
				       0);
    /* We need to clear the high-bit in the type field
     * (page 14-17 in the ProC/C++ manual). See the "new" SQLLIB names.
     */
    sqlnul(&(select_dp->T[j]), &(select_dp->T[j]), &null_ok); 
    /* SQLColumnNullCheck(SQL_SINGLE_RCTX,
     * &(select_dp->T[j]), &(select_dp->T[j]), &null_ok); 
     */

    flds->nullOk[j] = (Sint) null_ok; 
    flds->type[j] = (Sint) select_dp->T[j];

    ORACLE_internal_type = select_dp->T[j];
    switch(ORACLE_internal_type) {
    case  ORA_IN_CHAR:                     /* up to 255 chars */
      flds->length[j] = (Sint) select_dp->L[j];
      flds->isVarLength[j] = (Sint) 0;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      break;
    case  ORA_IN_VARCHAR2 :                /* up to 20000 chars */
      /* Note that on input, Oracle strips blanks from a VARCHAR2
       * variable, so we'll need to do the same on output (fetch).
       */
      flds->length[j] =  (Sint) select_dp->L[j];
      flds->isVarLength[j] = (Sint) 1;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      break;
    case  ORA_IN_NUMBER :
      /* extract precision and scale. */
      sqlprc(&(select_dp->L[j]), &precision, &scale); 
      /* SQLNumberPrecV6(SQL_SINGLE_RCTX,
       *  &(select_dp->L[j]), &precision, &scale);
       */
      if(precision==0 && scale==0){  
	/* This means the field has an unspecified NUMBER, thus we allow
	 * for the maximum size of NUMBER (see Table 2 in  the SQL Ref).
	 */
	precision = 38;   /* TODO: these should be define'd!!! */
	scale = 127; 
      }
      if (precision == 0) precision = 40;
      /* Also allow for decimal point and  possible sign. convert
       * NUMBER datatype to DOUBLE if scale > 0 or if precision is too
       * big to fit in a C long.
       */
      if(scale > 0 || precision > 10 ){ /* BUG: is 10 too big for R? */
	select_dp->T[j] = ORA_EX_FLOAT;
	select_dp->L[j] = sizeof(double);   /* len of the Oracle's buffer*/
	flds->Sclass[j] = (Stype) NUMERIC_TYPE;
      }  
      else {
	select_dp->T[j] = ORA_EX_INTEGER;
	select_dp->L[j] = sizeof(Sint);
	flds->Sclass[j] = (Stype) INTEGER_TYPE;
      } 
      flds->length[j] = (Sint) select_dp->L[j];
      flds->precision[j] = (Sint) precision;
      flds->scale[j] = (Sint) scale;
      flds->isVarLength[j] = (Sint) 0;
      break;
    case  ORA_IN_LONG : /* variable LONG char (NOT integer!) datatype */
      select_dp->T[j] = ORA_EX_VARCHAR2;
      if(select_dp->L[j] > RS_ORA_MAX_STRING)     /* string too long? */
        select_dp->L[j] = RS_ORA_MAX_STRING+1;    /* truncate */
      flds->length[j] = (Sint) select_dp->L[j];
      flds->isVarLength[j] = (Sint) 1;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      break;
    case ORA_IN_ROWID : /* ROWID is also a char-like  datatype */
      select_dp->T[j] = ORA_EX_VARCHAR2;
      select_dp->L[j] = 18+1;
      flds->length[j] = select_dp->L[j];
      flds->isVarLength[j] = (Sint) 0;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      break;
    case ORA_IN_DATE : /* TODO:  DATE datatype, should we return chrons?*/
      select_dp->T[j] = ORA_EX_VARCHAR2;
      select_dp->L[j] = 64;
      flds->length[j] = select_dp->L[j];
      flds->isVarLength[j] = (Sint) 1;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      break;
    case ORA_IN_RAW : /* RAW datatype (up to 255 bytes) */
      select_dp->T[j] = ORA_EX_VARCHAR2;
      flds->length[j] = (Sint) select_dp->L[j];
      flds->isVarLength[j] = (Sint) 0;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE; /* BUG: should be RAW_TYPE*/
      break;
    case ORA_IN_LONGRAW : /* LONG RAW datatype (upto 2147484647 bytes)*/
      select_dp->T[j] = ORA_EX_VARCHAR2;
      if(select_dp->L[j]>255){
	select_dp->L[j] = 255;
	RS_DBI_errorMessage("Oracle LONG RAW type extracted as CHARZ(255))", 
			    RS_DBI_WARNING);
      }
      flds->length[j] = (Sint) 255;
      flds->isVarLength[j] = (Sint) 0;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE; /* BUG: should be RAW_TYPE*/
      break;
    default:
      select_dp->T[j] = ORA_EX_VARCHAR2;
      flds->length[j] = (Sint) 255;
      flds->isVarLength[j] = (Sint) 1;
      flds->Sclass[j] = (Stype) CHARACTER_TYPE;
      (void) sprintf(errMsg,
		     "unkown ORA type %d (extracted as STRING(255))", 
                     ORACLE_internal_type);
      RS_DBI_errorMessage(errMsg, RS_DBI_WARNING);
      break;
    }

    /* we now allocate space for the receiving buffer -- better not lie! */

    if(select_dp->V[j] != (char *) 0)
       free(select_dp->V[j]);
    select_dp->V[j] = (char *) calloc((size_t) bufferSize, select_dp->L[j]);

    if(select_dp->I[j] != (short *) 0)
       free(select_dp->I[j]);
    select_dp->I[j] = (short *)calloc((size_t) bufferSize, sizeof(short));
  }  
  return flds;
}


/* copy "n_rows" from the Oracle's SQL Description Area buffers into
 * the data.frame "output" starting at row "from".
 * Recall that Oracle NULL indicater can be -1 (NULL), 0 (non-null), or
 * 1 (value truncated).
 */
void
RS_Ora_cpyOraToDataFrame(SQLDA *select_dp, int n_rows, 
   s_object *output, int from, RS_DBI_fields *flds)
{
   int    num_fields = flds->num_fields;
   int    r, j, len; 
   Sint   isVarLength;
   short  *null_item;
   char   *V, *out;

   for(j = 0; j < num_fields; j++){

      isVarLength = (int) flds->isVarLength[j];

      null_item = select_dp->I[j];      /* array of indicator for each row */
      len = select_dp->L[j];            /* all field elements have same len*/
      V = select_dp->V[j];              /* actual j'th buffer */
      
      switch((int)flds->Sclass[j]){
      case CHARACTER_TYPE:
         /* Note: We delete trailing blanks only in the case of 
          * variable-length  character types (varchar2, varchar, 
          * string, etc.)
          */
         for(r = 0; r < n_rows; r++){
            if(null_item[r]>=0){
               out = RS_DBI_nCopyString(&V[r*len], (size_t) len, isVarLength);
               SET_LST_CHR_EL(output,j,from+r, C_S_CPY(out));
               free(out);
               if(null_item[r]>0)
                  RS_DBI_errorMessage("truncated value", RS_DBI_WARNING);
            }
            else 
               SET_LST_CHR_EL(output,j,from+r,NA_STRING);
         }
         break;
      case INTEGER_TYPE:
         for(r = 0; r < n_rows; r++){
            if(null_item[r]>=0){
               LST_INT_EL(output,j,from+r) = ((Sint *) V)[r];
               if(null_item[r]>0)
                  RS_DBI_errorMessage("truncated value", RS_DBI_WARNING);
            }
            else
               NA_SET(&(LST_INT_EL(output,j,from+r)), INTEGER_TYPE);
         }
         break;
      case NUMERIC_TYPE:
         for(r = 0; r < n_rows; r++){
            if(null_item[r]>=0){
               LST_NUM_EL(output,j,from+r) = ((double *) V)[r];
               if(null_item[r]>0)
                  RS_DBI_errorMessage("truncated value", RS_DBI_WARNING);
            }
            else
               NA_SET(&(LST_NUM_EL(output,j,from+r)), NUMERIC_TYPE);
         }
         break;
#ifndef USING_R
      case SINGLE_TYPE:
         for(r = 0; r < n_rows; r++){
            if(null_item[r]>=0){
               LST_FLT_EL(output,j,from+r) = ((float *) V)[r];
               if(null_item[r]>0)
                   RS_DBI_errorMessage("truncated value", RS_DBI_WARNING);
            }
            else
               NA_SET(&(LST_FLT_EL(output,j,from+r)), SINGLE_TYPE);
        }
        break;
      case RAW_TYPE:
        /************************************************************
         *          BUG: Totally untested code!                     *
         *                                                          *
         * Note that as of version 0.3 we should not be here -- the *
         * RS_Ora_setOraToSMapping() does *not* generate codes for  *
         * any of the RAW types.                                    *
         ************************************************************
         */
        for(r = 0; r < n_rows; r++){
           raw_obj = NEW_RAW((Sint) flds->length[i]);
           raw_container = LST_EL(output, j);
           SET_ELEMENT(raw_container, (Sint) from+r, raw_obj);
           SET_ELEMENT(output, (Sint)j, raw_container);
        }
        break;
#endif
      }   /* switch */
   }      /* for j'th field */
   return;
}

/* set data mappings from R/S to Oracle.
 * These mappings are used in the processing of bound parameters.
 * We return the number of bound parameters.
 */
int
RS_Ora_setSToOraMappings(
   RS_Ora_desArea *desArea,
   s_object  *s_bind_classes
   )
{

   SQLDA  *bind_dp;
   size_t bufferSize;
   int    i,j; 
   long   n_params;
   Sint   nc, *which, nfld;
   short  *T, valid_fieldNum;
   long   *L;
   char   *c;

   Stype *Sclass; 

   bind_dp = desArea->bindVars;
   bufferSize = (size_t) desArea->bufferSize;

   n_params = bind_dp->F;
   if(n_params<0){
      RS_DBI_errorMessage(
         "could not bind input parameters in the sql statement",
         RS_DBI_WARNING);
      return -1;
   }
   nc = GET_LENGTH(s_bind_classes);
   if(n_params>nc){
      RS_DBI_errorMessage("number of parameters must equal ncol(data)",
         RS_DBI_ERROR);
      return -1;
   }
   desArea->numParams = n_params;
   bind_dp->N = n_params;

   if(n_params==0 || nc==0){
      return n_params;
   }

   T = (short *) bind_dp->T;
   L = (long *) bind_dp->L;

   Sclass = RS_SclassNames_To_StypeIds(s_bind_classes);
   desArea->Sclass = Sclass;
   which = (Sint *) calloc((size_t) n_params, sizeof(Sint));
   if(!which)
      RS_DBI_errorMessage("could not allocate desArea->which", RS_DBI_ERROR);
   desArea->which = which;

   for(j=0; j<n_params; j++){

      /* get col number being bound and make sure that it is valid 
       * (unfortunately S field names may not be valid binding parameter
       * names, e.g., "lat.1" is a valid S name but invalid SQL name).
       *
       * bind_dp->S[j] is the jth bind parameter names/string 
       * bind_dp->C[j] is the num of chararacter in the name
       */ 
      valid_fieldNum = 1;
      for(i=0, c = bind_dp->S[j]; i<bind_dp->C[j]; i++){
         if(!isdigit(c[i])){
            valid_fieldNum = 0;
            break;
         }
      }
      nfld = atol(bind_dp->S[j]);
      if(valid_fieldNum && nfld<1)
         valid_fieldNum = 0;
      if(!valid_fieldNum){
         char errMsg[128];
         (void) sprintf(errMsg,"invalid column number (%s) into data.frame",c);
         RS_DBI_errorMessage(errMsg, RS_DBI_WARNING);
         return -1;
      }

      which[j] = nfld;

      switch(Sclass[j]){
         case CHARACTER_TYPE:
            T[j] = ORA_EX_CHARZ; /* null-terminated string w. <= 255 chars */
            L[j] = (long) -1;    /* un-allocated buffer */
            bind_dp->V[j] = (char *) 0; /* cannot allocate space until I see the data*/
            break;
         case NUMERIC_TYPE:
            T[j] = ORA_EX_FLOAT;
            L[j] = (long) sizeof(double);
            bind_dp->V[j] = (char *) calloc(bufferSize, L[j]);
            break;
         case INTEGER_TYPE:
         case LOGICAL_TYPE:
            T[j] = ORA_EX_INTEGER;
            L[j] = (long) sizeof(Sint);
            bind_dp->V[j] = (char *) calloc(bufferSize, L[j]);
            break;
#ifndef USING_R
         case SINGLE_TYPE:
            T[j] = ORA_EX_FLOAT;
            L[j] = (long) sizeof(double);
            bind_dp->V[j] = (char *) calloc(bufferSize, L[j]);
            break;

         case RAW_TYPE:
            RS_DBI_errorMessage("raw type not yet implemented", RS_DBI_ERROR);
            break;
#endif
         default:
            RS_DBI_errorMessage("unrecognized type", RS_DBI_ERROR);
            break;
      }

      /* we now unconditionally set aside an indicator variable for each
       * bound parameter. Note that we don't need the X, Y, Z entries in
       * bind_dp that deal with indicator variables, since we handle
       * those explicitly.
       */
      bind_dp->I[j] = (short *) calloc(bufferSize, sizeof(short));
   }

   desArea->batchNum = 0;

   return n_params;
}

/* copy data from a data.frame into Oracle descriptor buffers.
 * Return the number of rows actually copied.
 */
int
RS_Ora_cpyDataFrameToOra(
   s_object *input,         /* input data.frame */
   s_object *s_data_class,  /* sapply(input,class) -- may be computed here */
   int      from,           /* starting row on input */
   int      n_rows,         /* how many rows to copy (must be <= bufferSize)*/
   RS_Ora_desArea *desArea  /* Oracle's description area and buffers */
   )
{
   SQLDA  *bind_dp;
   size_t bufferSize;
   int    n, nc, i, j, k, *fld_len;
   Sint   nr, d, max_col, *which, df_field;
   Stype  *Sclass, *dfclass;
   double x;
#ifndef USING_R
   float  f;
#endif
   char   *V, *schars, *here;
   short  *I, validClasses;
   long   L, L1, n_params;

   bind_dp = desArea->bindVars;
   n_params = bind_dp->F;
   bufferSize = (size_t) desArea->bufferSize;
   Sclass = desArea->Sclass;
   which  = desArea->which;

   dfclass = RS_SclassNames_To_StypeIds(s_data_class); /* this df's classes */

   nr = (Sint) GET_LENGTH(LST_EL(input, 0)); /* input's dimension */
   max_col = GET_LENGTH(input)-1;            /* for checking col nums */
   n_rows = (int) RS_Ora_Min(n_rows, bufferSize);
   n_rows = (int) RS_Ora_Min(n_rows, nr - from); /* actual num rows to copy */
   if(n_rows<1)
      return 0;

   /* We need to determine the (common) length for each character field
    * (recall that this info is unavailble when the bind_dp is initialized)
    *
    * Also very important, we need to verify that the new data.frame
    * and its fields have the same classes as the "prepared" bound fields.
    */

   fld_len = (int *) calloc((size_t) n_params, sizeof(int));
   if(!fld_len)
      RS_DBI_errorMessage(
         "could not allocate mem during R/S -> oracle copy", RS_DBI_ERROR);
   
   validClasses = 1;
   for(j=0; j<n_params; j++){

      df_field = which[j]-1;             /* "which" indexes are 1-based */
   
      /* bound column number must be in 1:nrow(input) ? */
      if(df_field<0 || df_field>max_col){
         char errMsg[128];
         (void) sprintf(errMsg, 
                "bound column %d must be in 1:ncol(data)=%d",
                (int) df_field+1, (int) max_col+1);
         RS_DBI_errorMessage(errMsg, RS_DBI_WARNING);
         validClasses = 0;
         continue;
      }

      /* data and bound column classes must agree*/
      if(Sclass[j]!=dfclass[df_field]){  
         char errMsg[128];
         (void) sprintf(errMsg, 
                "incompatible classes for bound parameter %d and data field %d",
                (int) j+1, (int) df_field+1);
         RS_DBI_errorMessage(errMsg, RS_DBI_WARNING);
         validClasses = 0;
         continue;
      }

      if(Sclass[j]==CHARACTER_TYPE){
         n = 0;
         for(i=0; i<n_rows; i++){
            nc = strlen(LST_CHR_EL(input, df_field, from+i));
            n = RS_Ora_Max(n, nc);
         }
         bind_dp->V[j] = (char *) calloc(bufferSize, n+1);  /* plus '\0' */
         bind_dp->L[j] = fld_len[j] = n+1;
      }
      else 
         fld_len[j] = bind_dp->L[j];
   }

   if(!validClasses){
      if(fld_len) free(fld_len);
      if(dfclass) free(dfclass);
      RS_DBI_errorMessage(
         "could not bind data to prepared statement", RS_DBI_ERROR);
   }

   /* we now do the actual copying */
   
   for(j=0; j<n_params; j++){

      V = bind_dp->V[j];   /* pointer to buffer of values */
      I = bind_dp->I[j];   /* pointer to buffer of NA/NULL indicators */
      L = bind_dp->L[j];   /* length of the field (all elems in V buffer) */
      L1 = L-1;
      df_field = which[j]-1; /* index into the input data.frame */

      switch(Sclass[j]){

         case CHARACTER_TYPE:
            for(i=0; i<n_rows; i++){
               schars = LST_CHR_EL(input, df_field, from+i);
#ifdef USING_R
               if(STRING_ELT(LST_EL(input,df_field),from+i)==NA_STRING)
#else
               if(IS_NA(schars, CHARACTER_TYPE))   /* S-Plus specific */
#endif
                  I[i] = (short) -1;               /* must be -1, not 1 */
               else {
                  I[i] = (short) 0;  /* must re-init to clear prev. field's */
                  here = &V[i*L];
                  (void) strncpy(here, schars, L1);      /* leave space for eos */
                  for(k=(int) strlen(schars); k<L1; k++)  /* needs padding w. spaces */
                     here[k] = ' ';
                  here[L1] = '\0';
               }
            }
            break;

         case NUMERIC_TYPE:
            for(i=0; i<n_rows; i++){
               x = LST_NUM_EL(input, df_field, from+i);
               if(IS_NA(&x, NUMERIC_TYPE))
                  I[i] = (short) -1;
               else {
                  I[i] = (short) 0;
                  ((double *)V)[i] = (double) x;
               }
            }
            break;

         case INTEGER_TYPE:    /* we use the fact that logical *are* int */
         case LOGICAL_TYPE:
            for(i=0; i<n_rows; i++){
               d = LST_INT_EL(input, df_field, from+i);
               if(IS_NA(&d, INTEGER_TYPE))
                  I[i] = (short) -1;
               else {
                  I[i] = (short) 0;
                  ((Sint *)V)[i] = (Sint) d;
               }
            }
            break;
#ifndef USING_R
         /* S-Plus also needs to RAW_TYPE */
         case SINGLE_TYPE:
            for(i=0; i<n_rows; i++){
               f = LST_NUM_EL(input, df_field, from+i);
               if(IS_NA(&f, SINGLE_TYPE))
                  I[i] = (short) -1;
               else {
                  I[i] = (short) 0;
                  ((float *)V)[i] = (float) f;
               }
            }
            break;
#endif
         default:
            RS_DBI_errorMessage("unrecognized R/S type", RS_DBI_ERROR);
            break;
      }
   }
   return n_rows;
}

s_object *   /* return a data.frame */
RS_Ora_fetch(Res_Handle *rsHandle, s_object *max_rec, s_object *ora_buf_size)
{
   /* We return a data.frame of num_fields, with at most num_rec in each fields
    * (field descriptions are coming from result->flds).
    */

   S_EVALUATOR

   EXEC SQL BEGIN DECLARE SECTION;
      int  bufferSize;
   EXEC SQL END DECLARE SECTION;

   s_object         *output;
#ifndef USING_R
   s_object          *raw_obj, *raw_container;
#endif
   RS_DBI_manager   *mgr;
   RS_DBI_resultSet *result;
   RS_DBI_fields    *flds;
   RS_Ora_desArea   *desArea;
   SQLDA            *select_dp;
   Sint   i, num_rec, expand, buf_size;
   long   n_rows, cum_rows, prev_rows; /* rows buffered */
   int    num_fields, cursorNum;
   char   alias[128]; 
 
   mgr = RS_DBI_getManager(rsHandle);
   result = RS_DBI_getResultSet(rsHandle);
   if(!result->isSelect)
      RS_DBI_errorMessage(
         "non-select statement -- no output to fetch", RS_DBI_ERROR);
   flds = result->fields;
   if(!flds)
      RS_DBI_errorMessage("internal error: corrupt dbResult object", 
			RS_DBI_ERROR);
   desArea = (RS_Ora_desArea *) result->drvData;
   num_rec = INT_EL(max_rec,0);
   expand = (Sint) (num_rec<0);
   if(expand || num_rec==((Sint) 0))
      num_rec = mgr->fetch_default_rec;

   buf_size = INT_EL(ora_buf_size, 0);
   if(buf_size<=0)
      bufferSize = RS_Ora_Min(desArea->bufferSize, num_rec);
   else
      bufferSize = buf_size;
   num_fields = flds->num_fields;
   MEM_PROTECT(output = NEW_LIST((Sint) num_fields));
   RS_DBI_allocOutput(output, flds, num_rec, 0);
#ifndef USING_R
   if(IS_LIST(output))
      output = AS_LIST(output);
   else
      RS_DBI_errorMessage("internal error: could not alloc output list",
			 RS_DBI_ERROR);
#endif
   /* Now we loop over at most num_rec and fetch them from the cursor */

   cursorNum = RS_Ora_getCursorNum(rsHandle);
   (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
   RS_Ora_varCharCpy(&db_alias, alias);

   select_dp = desArea->selectFlds;
 
   EXEC SQL WHENEVER SQLERROR  GOTO fetch_error;
   EXEC SQL WHENEVER NOT FOUND GOTO done;

   prev_rows = sqlca.sqlerrd[2];  /* rows fetched during prev RS_Ora_fetch */
   n_rows = bufferSize;

   for(i = 0; ; i += n_rows){
      /* do we need to expand (re-alloc) row-wise the output list? */
      if(i+bufferSize > num_rec){
         if(expand){
            num_rec = 2 * num_rec;
            RS_DBI_allocOutput(output, flds, num_rec, expand);
#ifndef USING_R
            if(IS_LIST(output))
               output = AS_LIST(output);
            else
               RS_DBI_errorMessage("input fetch error: could not alloc output list",
                                 RS_DBI_ERROR);
#endif
         }
         else {
            bufferSize = num_rec - i; /* last trip to db w. fewer rows */
            if(bufferSize==0)
               goto done;
         }
      }

      /* get next record from the proper cursor */
      switch(cursorNum) {
      case 0:
          EXEC SQL FOR :bufferSize FETCH C_00 USING DESCRIPTOR select_dp;
          break;
      case 1:
         EXEC SQL FOR :bufferSize FETCH C_01 USING DESCRIPTOR select_dp;
         break;
      case 2:
         EXEC SQL FOR :bufferSize FETCH C_02 USING DESCRIPTOR select_dp;
         break;
      case 3:
         EXEC SQL FOR :bufferSize FETCH C_03 USING DESCRIPTOR select_dp;
         break;
      case 4:
         EXEC SQL FOR :bufferSize FETCH C_04 USING DESCRIPTOR select_dp;
         break;
      case 5:
         EXEC SQL FOR :bufferSize FETCH C_05 USING DESCRIPTOR select_dp;
         break;
      case 6:
         EXEC SQL FOR :bufferSize FETCH C_06 USING DESCRIPTOR select_dp;
         break;
      case 7:
         EXEC SQL FOR :bufferSize FETCH C_07 USING DESCRIPTOR select_dp;
         break;
      case 8:
         EXEC SQL FOR :bufferSize FETCH C_08 USING DESCRIPTOR select_dp;
         break;
      case 9:
         EXEC SQL FOR :bufferSize FETCH C_09 USING DESCRIPTOR select_dp;
         break;
      default:
         goto fetch_error;
         break;
      }

      /* how many rows were actually transfered (we requested bufferSize) 
       * Note that we need to track of 
       *   (1) total num of rows fetched from the result set (this
       *       includes across invocations of RS_Ora_fetch)
       *   (2) rows fetched this one iteration (at most bufferSize, 
       *       possibly fewer)
       *   (3) rows fetch during this RS_Ora_fetch invocation (need to
       *       fetch num_rec)
       */

      cum_rows = sqlca.sqlerrd[2];   /* total rows fetched so far */
      n_rows = cum_rows - prev_rows;  /* rows fetched in this iteration */
      prev_rows = cum_rows;                 

      /* move data in SQL descriptor area buffers into the output data.frame */
      RS_Ora_cpyOraToDataFrame(select_dp, n_rows, output, i, flds);

   }
 
done:  
   /* actual number of records fetched */
   cum_rows = sqlca.sqlerrd[2];
   n_rows = cum_rows - prev_rows;
   prev_rows = cum_rows;
   if(n_rows>0){      /* any remaining rows in the oracle buffers? */
      RS_Ora_cpyOraToDataFrame(select_dp, n_rows, output, i, flds);
      i += n_rows;
   }

   if(i < num_rec){  /* do we neet to trim output data.frame? */
      s_object *s_tmp; int  j;

      num_rec = i;
      for(j = 0; j<num_fields; j++){
         s_tmp = LST_EL(output, j);
         MEM_PROTECT(SET_LENGTH(s_tmp, num_rec));
         SET_ELEMENT(output, j, s_tmp);
         MEM_UNPROTECT(1);
      }
   }

  if(sqlca.sqlcode == ORA_END_OF_DATA)
    result->completed = 1;
  else
    result->completed = (Sint) 0;

  result->rowCount += num_rec;

  MEM_UNPROTECT(1);

  return output;

fetch_error:  /* abort */
   RS_Ora_error();
   return (s_object *) NULL;
}

s_object *   /* boolean */
RS_Ora_closeResultSet(Res_Handle *rsHandle)
{
  S_EVALUATOR
  s_object *output;
  RS_DBI_resultSet *result;
  
  result = RS_DBI_getResultSet(rsHandle);
  
  if(result->drvData){
    RS_Ora_freeDescriptors((RS_Ora_desArea *) result->drvData);
    result->drvData = (void *) NULL;
  }
  RS_Ora_closeCursor(rsHandle);
  RS_DBI_freeResultSet(rsHandle);
  MEM_PROTECT(output = NEW_LOGICAL((Sint)1));
  LGL_EL(output,0) = TRUE;
  MEM_UNPROTECT(1);

  return output;
}

/* In this function we allocate descriptors both for  bind variables
 * and selected fields.  This is the SQL92 way of defining the
 * the communication between C host variables and cursors and selected
 * fields (active or result sets).  Note that this is half of the
 * mapping between S/R and the DBMS -- i.e., here we map the data
 * between the database and the DBI (C).  In the function 
 * RS_Ora_setOraToSMappings() we create the second half by an S list 
 * with the mapping between the DBI (C) and S.
 */
RS_Ora_desArea *
RS_Ora_allocDescriptors(int size, int max_vname_len, int max_iname_len, 
   Sint buf_size)
{
  int i;
  RS_Ora_desArea  *desArea;
  SQLDA           *bind_dp;     /* R/S-Plus bound data.frame fields */
  SQLDA           *select_dp;   /* select item list */
  /*  (The following is verbatim from the Oracle's demo10.pc file)
   * 
   *  Allocate the BIND and SELECT descriptors using sqlald().
   *  Also allocate the pointers to indicator variables
   *  in each descriptor.  The pointers to the actual bind
   *  variables and the select-list items are realloc'ed in
   *  the set_bind_variables() or process_select_list()
   *  routines.  This routine allocates 1 byte for select_dp->V[i]
   *  and bind_dp->V[i], so the realloc will work correctly.
   *  [I've got rid of this in order to implement host arrays -- dj]
   *
   * The first sqlald parameter determines the maximum number
   * of array elements in each variable in the descriptor. In
   * other words, it determines the maximum number of bind
   * variables or select-list items in the SQL statement.
   *
   * The second parameter determines the maximum length of
   * strings used to hold the names of select-list items
   * or placeholders.  The maximum length of column 
   * names in ORACLE is 30, but you can allocate more or less
   * as needed.
   *
   * The third parameter determines the maximum length of
   * strings used to hold the names of any indicator
   * variables.  To follow ORACLE standards, the maximum
   * length of these should be 30.  But, you can allocate
   * more or less as needed.
   */
  bind_dp = sqlald(size, max_vname_len, max_iname_len);
  /*
   * bind_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX,
   *            size, max_vname_len, max_iname_len);
  */
  if(bind_dp == (SQLDA *) 0) {
    RS_DBI_errorMessage("cannot allocate memory for bind descriptor",
		       RS_DBI_ERROR);
    return (RS_Ora_desArea *) NULL;
  }
  select_dp = sqlald (size, max_vname_len, max_iname_len); 
  /* select_dp = SQLSQLDAAlloc(SQL_SINGLE_RCTX,
   *             size, max_vname_len, max_iname_len);
   */
  if(select_dp == (SQLDA *) 0) {
    /* BUG: free bind_dp */
    RS_DBI_errorMessage("cannot allocate memory for select descriptor",
		       RS_DBI_ERROR);
    return (RS_Ora_desArea *) NULL;
  }
  select_dp->N = RS_ORA_MAX_ITEMS;

  for (i = 0; i < RS_ORA_MAX_ITEMS; i++) {
    /* TODO: instead of allocating only 1 entry per fields, we could
     * set aside N rows to be fetched all at once, saving network bandwidth
     * and cutting substantially the number of times we invoke FETCH.
     */
    bind_dp->V[i] = (char *) 0;           /* to be determined */
    bind_dp->I[i] = (short *)0;           /* to be determined */
    select_dp->V[i] = (char *) 0;         /* to be determined */
    select_dp->I[i] = (short *)0;         /* to be determined */
  }

  desArea = (RS_Ora_desArea *) malloc(sizeof(RS_Ora_desArea));
  desArea->bindVars = bind_dp;
  desArea->selectFlds = select_dp;
  desArea->batchNum  = -1;                /* to be determined */
  desArea->numParams = -1;                /* to be determined */
  desArea->Sclass = (Stype *) 0;          /* to be determined */
  desArea->which =  (Sint *) 0;           /* to be determined */
  /* buffer sizes (all equal, of course) */
  if(buf_size<1)
     buf_size = RS_ORA_DEFAULT_BUFFER_SIZE;
  if(buf_size > RS_ORA_MAX_BUFFER_SIZE){
     char err_msg[1024];
     buf_size = RS_ORA_MAX_BUFFER_SIZE;
     (void) sprintf(err_msg,
                    "potentially to big an Oracle buffer, reset to %ld",
                    (long) buf_size);
     RS_DBI_errorMessage(err_msg, RS_DBI_WARNING);
  }
  desArea->bufferSize = buf_size;
  return desArea;
}

void
RS_Ora_freeDescriptors(RS_Ora_desArea *desArea)
{
  Sint i;
  SQLDA *bind_dp = NULL;
  SQLDA *select_dp = NULL;

  if(!desArea)
    return;
  bind_dp = desArea->bindVars;
  if(bind_dp != (SQLDA *)0){
    for (i = 0; i < RS_ORA_MAX_ITEMS; i++){    
      if(bind_dp->V[i] != (char *) 0)
	free(bind_dp->V[i]);
      if(bind_dp->I[i] != (short *)0)
        free(bind_dp->I[i]);   /* RS_ORA_MAX_ITEMS were allocated. */
    }
  } 
  select_dp = desArea->selectFlds;
  if(select_dp != (SQLDA *) 0){
    for(i = 0; i < RS_ORA_MAX_ITEMS; i++){
      if(select_dp->V[i] != (char *) 0)
	free(select_dp->V[i]);
      if(select_dp->I[i] != (short *) 0)
        free(select_dp->I[i]); /* RS_ORA_MAX_ITEMS were allocated. */
    }
  }

  /* Free space used by the descriptors themselves. */
  (void) sqlclu(bind_dp); 
  (void) sqlclu(select_dp);
  /* 
   * SQLSQLDAFree(SQL_SINGLE_RCTX, bind_dp);
   * SQLSQLDAFree(SQL_SINGLE_RCTX, select_dp);
   */

  /* free the R/S-Plus type info */
  if(desArea->Sclass)
     free(desArea->Sclass);
  if(desArea->which)
     free(desArea->which);

  free(desArea);
  desArea = (RS_Ora_desArea *) NULL;

  return;
}

void  
RS_Ora_closeCursor(Res_Handle *rsHandle)
{
  int  cursorNum;
  char   alias[128];

  cursorNum = RS_Ora_getCursorNum(rsHandle);
  (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
  RS_Ora_varCharCpy(&db_alias, alias);
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  switch(cursorNum){
  case 0:
    EXEC SQL CLOSE C_00;  
    break;
  case 1:
    EXEC SQL CLOSE C_01;
    break;
  case 2:
    EXEC SQL CLOSE C_02;
    break;
  case 3:
    EXEC SQL CLOSE C_03;
    break;
  case 4:
    EXEC SQL CLOSE C_04;
    break;
  case 5:
    EXEC SQL CLOSE C_05;
    break;
  case 6:
    EXEC SQL CLOSE C_06;
    break;
  case 7:
    EXEC SQL CLOSE C_07;
    break;
  case 8:
    EXEC SQL CLOSE C_08;
    break;
  case 9:
    EXEC SQL CLOSE C_09;
    break;
  default:
    RS_DBI_errorMessage("internal error: could not close Oracle cursor",
			RS_DBI_WARNING);
    RS_Ora_error();
    break;
  }
  EXEC SQL WHENEVER SQLERROR DO RS_Ora_error();
  return;
}
    
/* commit work, return TRUE/FALSE */
s_object * 
RS_Ora_commit(s_object *conHandle)
{
   S_EVALUATOR

   s_object *status;
   int  cursorNum;
   char   alias[128];

   cursorNum = RS_Ora_getCursorNum(conHandle);
   (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
   RS_Ora_varCharCpy(&db_alias, alias);

   MEM_PROTECT(status = NEW_LOGICAL((Sint) 1));
   INT_EL(status,0) = TRUE;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL AT :db_alias COMMIT WORK;
   EXEC SQL WHENEVER SQLERROR DO RS_Ora_error();

   MEM_UNPROTECT(1);
   return status;
}

/* apparently we cannot code the name of savepoints into a host variable,
 * i.e., the following does not work w. ProC/C++
 * 
 *    char my_savepoint = "dummy1";
 *    EXEC SQL AT :db_alias SAVEPOINT :my_savepoint
 *    ...
 *    EXEC SQL AT :db_alias ROLLBACK WORK TO :my_savepoint
 */

s_object *
RS_Ora_rollback(s_object *conHandle)
{
   /* we must close all the result sets in the connection.  The current
    * implementation does this in the S function oraRollabck()
    */
   S_EVALUATOR

   s_object *status;
   int  cursorNum;
   char   alias[128];

   cursorNum = RS_Ora_getCursorNum(conHandle);
   (void) sprintf(alias, ALIAS_PATTERN, cursorNum);
   RS_Ora_varCharCpy(&db_alias, alias);

   MEM_PROTECT(status = NEW_LOGICAL((Sint) 1));
   INT_EL(status,0) = TRUE;

   EXEC SQL WHENEVER SQLERROR CONTINUE;
   EXEC SQL AT :db_alias ROLLBACK WORK;
   EXEC SQL WHENEVER SQLERROR DO RS_Ora_error();

   MEM_UNPROTECT(1);
   return status;
}

void
RS_Ora_error()
{
  char ora_msg[512];
  size_t buf_size = 512, msg_len;

  sqlglm(ora_msg, &buf_size, &msg_len); 
  /* SQLErrorGetText(SQL_SINGLE_RCTX, ora_msg, &buf_size, &msg_len); */
  ora_msg[msg_len++] = '\0';

  /* disable error handler (to avoid infinite loops!) */
  EXEC SQL WHENEVER SQLERROR CONTINUE;
  EXEC SQL ROLLBACK WORK;
  RS_DBI_errorMessage(ora_msg, RS_DBI_ERROR);
}

s_object *   /* named list */
RS_Ora_getException(s_object *conHandle)
{
  S_EVALUATOR
  
  s_object  *output;
  Sint  n = 2;
  char *exDesc[] = {"errorNum", "errorMsg"};
  Stype exType[] = {INTEGER_TYPE, CHARACTER_TYPE};
  Sint  exLen[]  = {1, 1};

  char ora_msg[512];
  size_t buf_size = 512, msg_len;
  int  ora_code;

  if(!RS_DBI_validHandle(conHandle))
    RS_DBI_errorMessage("invalid handle", RS_DBI_ERROR);
  output = RS_DBI_createNamedList(exDesc, exType, exLen, n);
#ifndef USING_R
  if(IS_LIST(output))
    output = AS_LIST(output);
  else
    RS_DBI_errorMessage("internal error: could not allocate named list",
			RS_DBI_ERROR);
#endif
  ora_code = sqlca.sqlcode;
  /* make sure we don't extract last (instead of current) message */
  if(ora_code != 0){ 
    sqlglm(ora_msg, &buf_size, &msg_len);
    /* SQLErrorGetText(SQL_SINGLE_RCTX, ora_msg, &buf_size, &msg_len); */
    ora_msg[msg_len++] = '\0';
  }
  else
    (void) sprintf(ora_msg, "OK");
  LST_INT_EL(output,0,0) = (Sint) ora_code;
  SET_LST_CHR_EL(output,1,0,C_S_CPY(ora_msg));
  
  return output;
} 

s_object *
RS_Ora_typeNames(s_object *oraTypes)
{
  S_EVALUATOR
  Sint n, i;
  Sint  this_type;
  char  *tname;
  char  *unknown = "<unknown>";
  s_object *oraNames;

  n = GET_LENGTH(oraTypes);
  MEM_PROTECT(oraNames = NEW_CHARACTER(n));
  for(i=0; i < n; i++){
    this_type = (int) INT_EL(oraTypes,i);
    tname = RS_DBI_getTypeName(this_type, RS_Ora_dataTypes);
    if(tname)
      SET_CHR_EL(oraNames, i, C_S_CPY(tname));
    else 
      SET_CHR_EL(oraNames, i, C_S_CPY(unknown)); 
  }
  MEM_UNPROTECT(1);
  
  return oraNames;
}

int 
RS_Ora_getCursorNum(Res_Handle *rsHandle)  
/* getCursorNum from either a connection or resultSet object */
{
  int  cursorNum;
  RS_DBI_manager *mgr;
  RS_DBI_manager *RS_DBI_getManager(Res_Handle *);
  
  mgr = RS_DBI_getManager(rsHandle);
  cursorNum = RS_DBI_lookup(mgr->connectionIds, mgr->length, CON_ID(rsHandle));
  return cursorNum;
}

void
RS_Ora_varCharCpy(void *vchar, const char *from)
{
  VARCHAR *to;
  to = (VARCHAR *) vchar;
  to->len = (unsigned short) strlen(from);
  (void) strcpy(to->arr, from);
  return;
}
s_object *         /* named list */
RS_Ora_managerInfo(Mgr_Handle *mgrHandle)
{
  S_EVALUATOR

  RS_DBI_manager *mgr;
  s_object *output;
  Sint  i, num_con;
  Sint n = (Sint) 8;
  char *mgrDesc[] = {"drvName","connectionIds", 
		     "fetch_default_rec", "managerId",
		     "length", "num_con", "counter", "clientVersion"};
  Stype mgrType[] = {CHARACTER_TYPE, INTEGER_TYPE, 
                     INTEGER_TYPE,   INTEGER_TYPE, INTEGER_TYPE, 
                     INTEGER_TYPE,   INTEGER_TYPE, CHARACTER_TYPE};
  Sint  mgrLen[]  = {1, 1, 1, 1, 1, 1, 1, 1};
  
  mgr = RS_DBI_getManager(mgrHandle);
  num_con = (Sint) mgr->num_con;
  mgrLen[1] = num_con;

  output = RS_DBI_createNamedList(mgrDesc, mgrType, mgrLen, n);
#ifndef USING_R
  if(IS_LIST(output))
    output = AS_LIST(output);
  else
    RS_DBI_errorMessage("internal error: could not alloc named list", 
			RS_DBI_ERROR);
#endif
  SET_LST_CHR_EL(output,0,0,C_S_CPY(mgr->drvName));
  for(i = 0; i < num_con; i++)
    LST_INT_EL(output,1,i) = (Sint) mgr->connectionIds[i];
  LST_INT_EL(output,2,0) = (Sint) mgr->fetch_default_rec;
  LST_INT_EL(output,3,0) = (Sint) mgr->managerId;
  LST_INT_EL(output,4,0) = (Sint) mgr->length;
  LST_INT_EL(output,5,0) = (Sint) mgr->num_con;
  LST_INT_EL(output,6,0) = (Sint) mgr->counter;
  SET_LST_CHR_EL(output,7,0, C_S_CPY(RS_ORA_VERSION));   /* client versions? */

  return output;
}

s_object *        /* return a named list */
RS_Ora_connectionInfo(Con_Handle *conHandle)
{
  S_EVALUATOR
  RS_DBI_connection  *con;
  RS_Ora_conParams   *conParams;
  s_object *output;
  Sint     i;
  Sint  n = (Sint) 8;
  char *conDesc[] = {"dbname", "user", "passwd", "conType",
		     "serverVersion", "protocolVersion",
		     "threadId", "resultSetIds"};
  Stype conType[] = {CHARACTER_TYPE, CHARACTER_TYPE, CHARACTER_TYPE,
                     CHARACTER_TYPE, CHARACTER_TYPE, CHARACTER_TYPE, 
		     INTEGER_TYPE, INTEGER_TYPE};
  Sint  conLen[]  = {1, 1, 1, 1, 1, 1, 1, -1};

  con = RS_DBI_getConnection(conHandle);
  conLen[n-1] = con->num_res;   /* number of resultSets opened */
  conParams = (RS_Ora_conParams *) con->conParams;

  output = RS_DBI_createNamedList(conDesc, conType, conLen, n);
#ifndef USING_R
  if(IS_LIST(output))
    output = AS_LIST(output);
  else
    RS_DBI_errorMessage("internal error: could not alloc named list",
			RS_DBI_ERROR);
#endif
  SET_LST_CHR_EL(output,0,0, C_S_CPY(conParams->dbname));
  SET_LST_CHR_EL(output,1,0, C_S_CPY(conParams->user));
  SET_LST_CHR_EL(output,2,0, C_S_CPY(conParams->passwd));
  SET_LST_CHR_EL(output,3,0, NA_STRING);      /* conType */
  SET_LST_CHR_EL(output,4,0, NA_STRING);      /* serverVersion */
  SET_LST_CHR_EL(output,5,0, NA_STRING);      /* protocol version*/
  LST_INT_EL(output,6,0) = (Sint) -1;                 /* threadId */

  for(i=0; i < con->num_res; i++)
    LST_INT_EL(output,7,(Sint) i) = con->resultSetIds[i];

  return output;
}

s_object *       /* return a named list */
RS_Ora_resultSetInfo(Res_Handle *rsHandle)
{
  S_EVALUATOR

  RS_DBI_resultSet   *result;
  s_object  *output, *flds;
  s_object  *RS_DBI_copyfields(RS_DBI_fields *flds);
  Sint  n = (Sint) 6;
  char  *rsDesc[] = {"statement", "isSelect", "rowsAffected",
		     "rowCount", "completed", "fields"};
  Stype rsType[]  = {CHARACTER_TYPE, INTEGER_TYPE, INTEGER_TYPE,
		     INTEGER_TYPE,   INTEGER_TYPE, LIST_TYPE};
  Sint  rsLen[]   = {1, 1, 1, 1, 1, 1};

  result = RS_DBI_getResultSet(rsHandle);
  if(result->fields)
    flds = RS_DBI_copyfields(result->fields);
  else
    flds = S_NULL_ENTRY;

  output = RS_DBI_createNamedList(rsDesc, rsType, rsLen, n);
#ifndef USING_R
  if(IS_LIST(output))
    output = AS_LIST(output);
  else
    RS_DBI_errorMessage("internal error: could not alloc named list",
			RS_DBI_ERROR);
#endif
  SET_LST_CHR_EL(output,0,0, C_S_CPY(result->statement));
  LST_INT_EL(output,1,0) = result->isSelect;
  LST_INT_EL(output,2,0) = result->rowsAffected;
  LST_INT_EL(output,3,0) = result->rowCount;
  LST_INT_EL(output,4,0) = result->completed;
  SET_ELEMENT(LST_EL(output, 5), (Sint) 0, flds);

  return output;
}

s_object *       /* return a named list */
RS_Ora_boundParamsInfo(Res_Handle *psHandle)
{
  S_EVALUATOR

  RS_DBI_resultSet   *result;
  RS_Ora_desArea     *desArea;
  s_object  *output;
  Sint  n = (Sint) 3, numParams;
  Sint   j;
  char  *bpDesc[] = {"parameter", "columnNum", "Sclass"};
  Stype bpType[]  = {INTEGER_TYPE, INTEGER_TYPE, INTEGER_TYPE};
  Sint  bpLen[]   = {-1, -1, -1};

  result = RS_DBI_getResultSet(psHandle);
  desArea = (RS_Ora_desArea *) result->drvData;
  numParams = desArea->numParams;
  if(numParams<0)
     return S_NULL_ENTRY;
  bpLen[0] = bpLen[1] = bpLen[2] = numParams;
  output = RS_DBI_createNamedList(bpDesc, bpType, bpLen, n);
#ifndef USING_R
  if(IS_LIST(output))
    output = AS_LIST(output);
  else
    RS_DBI_errorMessage("internal error: could not alloc named list",
			RS_DBI_ERROR);
#endif
  for(j = 0; j<numParams; j++){
     LST_INT_EL(output, 0, j) = j+1;                 /* param num */
     LST_INT_EL(output, 1, j) = desArea->which[j];   /* col num */
     LST_INT_EL(output, 2, j) = desArea->Sclass[j];  /* col class */ 
  }
  return output;
}

/* Given an S character vector of basic (primitive types) class names,
 * it returns a C array of the corresponding basic types.
 * This is a bit of a hack: why can't we just use RS_DBI_getTypeName()?
 */
Stype *
RS_SclassNames_To_StypeIds(s_object *s_col_classes)  
{

   Stype *S_dataClasses = NULL;
   Sint  ncols;
   int   j;
   char  *buff;

   ncols = GET_LENGTH(s_col_classes);
   S_dataClasses = (Stype *) calloc((size_t) ncols, sizeof(Stype));
   if(!S_dataClasses)
      RS_DBI_errorMessage(
         "could not calloc array for Stype", RS_DBI_ERROR); 
   for(j=0; j<ncols; j++){
      buff = CHR_EL(s_col_classes, (Sint) j);
      if(strcmp(buff, "character")==0)
         S_dataClasses[j] = CHARACTER_TYPE;
      else if(strcmp(buff, "numeric")==0)
         S_dataClasses[j] = NUMERIC_TYPE;
      else if(strcmp(buff, "logical")==0)
         S_dataClasses[j] = LOGICAL_TYPE;
      else if(strcmp(buff, "integer")==0)
         S_dataClasses[j] = INTEGER_TYPE;
#ifndef USING_R
      else if(strcmp(buff, "single")==0)      /* only on Splus */
         S_dataClasses[j] = SINGLE_TYPE;
      else if(strcmp(buff, "raw")==0)
         S_dataClasses[j] = RAW_TYPE;
#endif
      else {
         char errMsg[128];
         (void) sprintf(errMsg, "unrecognized S class %s ", buff);
         RS_DBI_errorMessage(errMsg, RS_DBI_ERROR);
         S_dataClasses[j] = (Stype) -1;
      }
  }
  return S_dataClasses;
}
