<!doctype s-function-doc system "s-function-doc.dtd" [
<!entity % S-OLD "INCLUDE">
]
>
<s-function-doc>
<s-topics>
<s-topic> fetch </s-topic>
</s-topics>
<s-title>
Fetch records from a previously executed SELECT statement
</s-title>
<s-description>
Fetch records from a previously executed SELECT statement
</s-description>
<s-usage>
<s-old-style-usage>
fetch(resultSet, n, ...)
</s-old-style-usage>
</s-usage>
<s-args-required>
<s-arg name= resultSet >
a <s-class>resultSet</s-class> object.
This object needs to be the result of a <code>SELECT</code>
or <code>SELECT</code>-like statement, as produced
by <s-function name="dbExecStatement.sgm">dbExecStatement.</s-function>
SQL statements such as <code>INSERT</code>, <code>DELETE</code>,
does not create result sets.
<p>
(Release note: as of release 0.3.1, all SQL statements produce result sets.
As of release 0.3.2 this incompatibility is fixed.)
</s-arg>
</s-args-required>
<s-args-optional>
<s-arg name= "n" >
maximun number of records to retrieve per fetch.
Use <code>n = -1</code> to retrieve all pending records.
Some implementations may recognize other special values
(RS-MySQL interprets <code>n = 0</code> to mean "use whatever
default was set in the call to <s-function name ="MySQL.sgm">MySQL</s-function>).
</s-arg>
<s-arg name= ... >
any other database-engine specific arguments.
</s-arg>
</s-args-optional>
<s-value>
a data.frame with as many rows as records  were fetched
and as many columns as fields in the result set.
</s-value>
<s-side-effects>
As the R/S client fetches records the remote databse server
updates its cursor accordingly.
</s-side-effects>
<s-details>
See the notes for the various databse server implementations.
</s-details>
<s-section name = "NOTE">
Make sure you close the result set with <code>close(resultSet)</code>
as soon as you finish retrieving the records you want.
<s-section name = "REFERENCES">
See the <url url="http://www.omegahat.org"
             name = "The Omega Project for Statistical Computing">
for details on the R/S interface to databses.
</s-section>
<s-see>
<descrip>
<tag>On database managers:</tag><p>
<s-function name="dbManager.sgm">dbManager</s-function>
<s-function name="MySQL.sgm">MySQL</s-function>
<s-function name="Oracle.sgm">Oracle</s-function>
<s-function name="load.sgm">load</s-function>
<s-function name="unload.sgm">unload</s-function>
<tag>On connections, SQL statements and resultSets:</tag><p>
<s-function name="dbExecStatement.sgm">dbExecStatement</s-function>
<s-function name="dbExec.sgm">dbExec</s-function>
<s-function name="fetch.sgm">fetch</s-function>
<s-function name="quickSQL.sgm">quickSQL</s-function>
<tag>On transaction management:</tag><p>
<s-function name="commit.sgm">commit</s-function>
<s-function name="rollback.sgm">rollback</s-function>
<tag>On meta-data:</tag><p>
<s-function name="describe.sgm">describe</s-function>
<s-function name="getVersion.sgm">getVersion</s-function>
<s-function name="getDatabases.sgm">getDatabases</s-function>
<s-function name="getTables.sgm">getTables</s-function>
<s-function name="getFields.sgm">getFields</s-function>
<s-function name="getCurrentDatabase.sgm">getCurrentDatabase</s-function>
<s-function name="getTableIndeces.sgm">getTableIndeces</s-function>
<s-function name="getException.sgm">getException</s-function>
<s-function name="getStatement.sgm">getStatement</s-function>
<s-function name="hasCompleted.sgm">hasCompleted</s-function>
<s-function name="getRowCount.sgm">getRowCount</s-function>
<s-function name="getAffectedRows.sgm">getAffectedRows</s-function>
<s-function name="getNullOk.sgm">getNullOk</s-function>
<s-function name="getInfo.sgm">getInfo</s-function>
</descrip>
<s-function name="rollback.sgm">rollback</s-function>
</s-see>
<s-examples>
<s-example>
# Run an SQL statement by creating first a resultSet object
> m <- MySQL()
> con <- dbConnect(m)    
> rs <- dbExecStatement(con, 
         statement = "SELECT w.laser_id, w.wavelength, p.cut_off 
                      FROM WL w, PURGE P
                      WHERE w.laser_id = p.laser_id
                      SORT BY w.laser_id")
> rs
MySQLResultSet id = (12629,1,3)

# we now fetch the first 100 records from the restulSet into a data.frame
> data1 <- fetch(rs, n = 100)   
> dim(data)
[1] 10  18

> hasCompleted(rs)
[1] 0

# let's get all remaining records
> data2 <- fetch(rs, n = -1)
</s-example>
</s-examples>
<s-keywords>
<s-keyword>RS-DBI</s-keyword>
<s-keyword>MySQL</s-keyword>
<s-keyword>databases</s-keyword>
<s-keyword>RDBMS</s-keyword>
<s-keyword>manip</s-keyword>
</s-keywords>
<s-docclass>
function
</s-docclass>
</s-function-doc>
