<!doctype s-function-doc system "s-function-doc.dtd" [
<!entity % S-OLD "INCLUDE">
]
>
<s-function-doc>
<s-topics>
<s-topic>Oracle</s-topic>
<s-topic>dbManager</s-topic>
</s-topics>
<s-title>
Instantiate an Oracle client from the current R or S session
</s-title>
<s-description>
This function creates and initializes an Oracle client from
the current R or S session.
It returns an object that allows you to connect to one
or more Oracle servers.
</s-description>
<s-usage>
<s-old-style-usage>
dbManger("Oracle", max.con = 10, ferch.default.rec = 500)

Oracle(max.con=10, fetch.default.rec=500)
</s-old-style-usage>
</s-usage>
<s-args-optional>
<s-arg name= max.con >
maximum number of connections that are expected to be opened simultaneously.
The current C implementation has a hard coded maximum of 10, but you may
request a smaller number if you know  you will not need all 10.
Be aware that some meta-data functions (e.g., 
<s-function name = "getVersion.sgm">getVersion</s-function>) may
need to open temporary connections to fetch data from Oracle's data
dictionaries.  To be safe, you should allow at least a couple of
simultaneous connections.
</s-arg>
<s-arg name= fetch.default.rec >
default number of records return per fetch. The default is
500, but see the documentation for 
<s-function name="fetch.sgm">fetch</s-function>.
</s-arg>
</s-args-optional>
<s-value>
an object of class <s-expression>OraManager</s-expression>
that extends <s-expression>dbManger</s-expression> and
<s-expression>dbObjectId</s-expression>.
You must provide such an Oracle manager to 
<s-function name="dbConnect.sgm">dbConnect</s-function>
in order to connect to individual database instances.
</s-value>
<s-side-effects>
The client portion of the R/S interface to Oracle is
initialized.
</s-side-effects>
<s-details>
This object is a singleton, that is, on subsequent invocations
this function returns the same (already) initialized object.
</s-details>
<s-section name = "USER AUTHORIZATION">
In this current implementation, you need to supply your
Oracle <code>username</code>, <code>password</code> and <code>dbname</code>
parameters as string arguments in the call to 
<s-function name="dbConnect.sgm">dbConnect.</s-function>
(The default value for <code>dbname</code> is the
value of the shell variable <code>$ORACLE_SID.)</code>
<p>
Unfortunately, this approach is insecure, and we might need
to implement a mechanism based on a configuration file similar
to the <s-function name="MySQL.sgm">MySQL</s-function> implementation
or the ODBC model.
</s-section>
<s-section name = "REFERENCES">
See <url name = "The Omega Project for Statistical Computing"
     url = "http://www.omegahat.org">
for more details on the R/S database interface.
<p>
See <url url="http://www.oracle.com" name = "Oracle's Web Site">
for details on Oracle.
</s-section>
<s-section name = "IMPLEMENTATION">
The current R/S to Oracle interface is based on embedded SQL
that is pre-compiled using the Oracle's ProC/C++ compiler.
Although not as flexible as using Oracle's Call Interface (OCI),
the embedded SQL approach  is based on the X/Open specification
and in principle could be easily re-use to connect to Informix,
Ingres, and possibly other RDBMS. But it does introduce
some limitations, for instance, in our implementation you can only 
have one open result set (query) per connection -- and the entire 
query needs to be read into R/S (or discarded) before another query 
may be processed on that one connection.  
The limitation is not too great, since we can have multiple connections, 
and thus we can easily have multiple queries opened simultaneously, 
but we do incur a (small) penalty in terms of resources.
</s-section>
<s-see>
<descrip>
<tag>On database managers:</tag><p>
  <s-function name="dbManager.sgm">dbManager</s-function>
  <s-function name="MySQL.sgm">MySQL</s-function>
  <s-function name="Oracle.sgm">Oracle</s-function>
  <s-function name="load.sgm">load</s-function>
  <s-function name="unload.sgm">unload</s-function>
  <s-function name="getConnections.sgm">getConnections</s-function>
<tag>On connections and running SQL:</tag><p>
  <s-function name="dbExec.sgm">dbExec</s-function>
  <s-function name="dbExecStatement.sgm">dbExecStatement</s-function>
  <s-function name="quickSQL.sgm">quickSQL</s-function>
  <s-function name="fetch.sgm">fetch</s-function>
  <s-function name="close.sgm">close</s-function>
  <s-function name="getResultSets.sgm">getResultSets</s-function>
<tag>On result sets:</tag><p>
  <s-function name="getFields.sgm">getFields</s-function>
  <s-function name="getStatement.sgm">getStatement</s-function>
  <s-function name="hasCompleted.sgm">hasCompleted</s-function>
  <s-function name="getRowCount.sgm">getRowCount</s-function>
  <s-function name="getAffectedRows.sgm">getAffectedRows</s-function>
  <s-function name="getNullOk.sgm">getNullOk</s-function>
  <s-function name="getConnection.sgm">describe</s-function>
  <s-function name="close.sgm">close</s-function>
<tag>On transaction management:</tag><p>
  <s-function name="commit.sgm">commit</s-function>
  <s-function name="rollback.sgm">rollback</s-function>
<tag>On meta-data:</tag><p>
  <s-function name="describe.sgm">describe</s-function>
  <s-function name="getVersion.sgm">getVersion</s-function>
  <s-function name="getDatabases.sgm">getDatabases</s-function>
  <s-function name="getTables.sgm">getTables</s-function>
  <s-function name="getCurrentDatabase.sgm">getCurrentDatabase</s-function>
  <s-function name="getTableIndeces.sgm">getTableIndeces</s-function>
  <s-function name="getException.sgm">getException</s-function>
  <s-function name="getInfo.sgm">getInfo</s-function>
</descrip>
</s-see>
<s-examples>
<s-example>
> # The following two expression are equivalent
> ora <- Oracle()  
> ora <- dbManager("Oracle").
> ora
OraManager id = (20527) 

> # connect to the databases "PIX" and "FMS"
> pix <- dbConnect(ora, user = "genuse", pass = pixPasswd,
                 dbname = "ALPIX")
> fms <- dbConnect(ora, user = "fms", pass = fmsPasswd,
                 dbname = "FMS")

> # some tables in the PIX database (available to us, that is)
> getTables(fms)[70:80,]
 [1] "HISTGRM$"              "HIST_HEAD$"            "DUAL"                 
 [4] "PARTOBJ$"              "PARTCOL$"              "TABPART$"             
 [7] "INDPART$"              "SYSTEM_PRIVILEGE_MAP"  "TABLE_PRIVILEGE_MAP"  
[10] "STMT_AUDIT_OPTION_MAP" "RESOURCE_MAP"         

> describe(fms, verbose = F)
OraConnection id = (21362,3) 
  User: sunuser 
  Dbname: FMS 
  No resultSet available

> rs <- dbExecStatement(fms, 
        "select SCORE from FMS_EVENTS where AREA = 'Caribbean'")
> fetch(rs, n = 3)
</s-example>
</s-examples>
<s-keywords>
<s-keyword>interface</s-keyword>
<s-keyword>data</s-keyword>
<s-keyword>manip</s-keyword>
<s-keyword>programming</s-keyword>
<s-keyword>utilities</s-keyword>
</s-keywords>
<s-docclass>
function
</s-docclass>
</s-function-doc>
